# exercise
# 피보나치 수열 만들어보기(단순재귀적 구현)
# n번째 피보나치 수가 무엇인지 알아내기
# 예) 4번째 피보나치 수는 1 ,1 ,2, 3, 5, 8 ... --> 3이 4번째 피보나치 수이다.

# def fibo(x):
#     if x == 1 or x == 2:
#         return 1
#     else:
#         return fibo(x-1) + fibo(x-2)
#
# print(fibo(30)) # fibo(30)을 구하기 위해서는 약 10억가량의 연산을 수행해야함
# 단순 재귀 함수로 피보나치 수열을 해결하면 지수시간복잡도를 가지게 된다. 즉 , x의 값이 조금만 커지게 된다면 기하급수적으로 많은 시간을 가지게 된다.
# 예 f(6)을 호출하면 f(2)가 "여러번 호출"(중복호출)되는 것을 확인 할 수 있음. --> 이 부분에 대한 값을 "이미 해결한 메모리"에 따로
# 기록을 해두지 않으면 들어오는 연산에 따른 처리가 반복적으로 계속 하기 때문에 빅오표기법에 따른 o(2^n)의 시간복잡도를 가지게되는 것이다.


# 피보나치 수열을 다이나믹프로그래밍을 이용해서 효율적으로 해결해보기 - 메모이제이션
# 조건을 만족하는지 확인 (조건 1 . 최적부분구조 / 조건 2 . 중복되는부분문제) --> 피보나치수열은 조건을 만족함

# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
dp = [0] * 100
# print(dp)


# 피보나치 함수를 재귀함수로 구현(탑-다운 다이나믹 프로그래밍)   시간복잡도 : o(N)
def fibo(x):
    # print(f"f({str(x)})",end=" ")
    if x == 1 or x == 2: # 종료조건 설정
        return 1
    if dp[x] != 0: # 이미 계산한적 있는 문제라면 그대로 반환
        return dp[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    # print(dp)
    dp[x] = fibo(x - 1) + fibo(x - 2)
    # print(dp)
    return dp[x]


print(fibo(6))

# 피보나치함수 (보텀-업 프로그래밍 소스코드, 반복문으로 구현)
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]
print(d[n])